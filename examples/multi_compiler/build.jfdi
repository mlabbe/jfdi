#    _______________ _____ 
#   |_  |  ___|  _  \_   _|
#     | | |_  | | | | | |  
#     | |  _| | | | | | |  
# /\__/ / |   | |/ / _| |_ 
# \____/\_|   |___/  \___/ 
#
"""
jfdi build script

available functions:
  log(str)      - print to stdout
  cmd(list|str) - run a command on a shell, fatal if error
  die(str)      - fail build with a message, errorlevel 3
  env(str)      - return environment variable or None
  obj(str)      - return filename with obj file ext (file.c = file.obj)
  exe(str)      - return filename with exe extension based on TARGET_OS
  ext(str)      - return file extension (file.c = .c)
  exp(str)      - expand a $string, using all global vars
  mkd(str)      - make all subdirs
  use('?')      - arm environment with make-like variables (LD, CC, etc.)
  arg(str)      - convert a /flag into a -flag depending on compiler
  var(str,type) - get command line var passed in with --var or ''
  pth(str)      - swap path slashes -- \ on windows, / otherwise
  new(src,dst)  - true if file src is newer than file dst
  cp(src, dst)  - copy a file or directory
  rm(str)       - remove file or directory

variables:
  HOST_OS       - compiling machine OS    (str)
  TARGET_OS     - target machine OS       (str)

after use(), variables, where applicable:
  CC            - c compiler
  CXX           - c++ compiler
  LD            - linker
  OBJ           - obj extension (ex: 'obj')
  CCTYPE        - compiler 
  CFLAGS        - list of c flags
  CXXFLAGS      - list of c++ flags
  LDFLAGS       - list of linker flags
  
"""

JFDI_VERSION = 1

cfg = {'i': pth(".\\intermediates\\")}







# called at the start of the build
def start_build():
    global cfg
    if HOST_OS == 'Windows':
        use("msvc")
    elif HOST_OS == 'Darwin':
        use("clang")
    elif HOST_OS == 'Linux':
        # Pass jfdi.py COMPILER=clang from the command line to build 
        # with clang on Linux.
        if var("COMPILER") == 'clang':
            log("overriding gcc with clang")
            use("clang")
        else:
            use("gcc")
        
    mkd(cfg['i'])

    # initialize CFLAGS here instead of in build_this(), since
    # build_this could be called many times and appending CFLAGS
    # there would just repeatedly fill it up.
    #
    # We check if jfdi.py DEBUG=1 was passed in and use different
    # compile flags.
    if var('DEBUG', bool):
        if CCTYPE == 'msvc':
            CFLAGS.append('/Od')
            CFLAGS.append('/Zi')
        elif CCTYPE == 'gcc':
            CFLAGS.append('-O0')
            CFLAGS.append('-g')
    else:
        # MSVC accepts /O2 and gcc-likes accept -O2.
        # arg() swaps the - for a /, accordingly.
        CFLAGS.append(arg('-O2'))


# return a list of files
def list_input_files():
    return ['hello.c']


# return command to build single file in_path or None to skip
def build_this(in_path):

    # obj_path is the path to the obj file, including the file name.
    # if msvc, this will have an .obj extension, otherwise .o
    #
    # obj()'s optional second parameter is the directory the obj is in.
    # Don't worry about dir slash direction -- this is automatically
    # swapped by the host OS.
    obj_path = obj(in_path, cfg['i'])
    if not new(in_path, obj_path):
        return None

    # Because we are pushing all intermediate files to a subdirectory,
    # we must tell the compiler where to put them.
    #
    # This is done differently on MSVC and gcc-likes, so we test
    # the compiler type with CCTYPE.
    #
    # Note: clang has the CCTYPE "gcc" because it is gcc-like.
    # This is done to reduce verbosity in testing.
    # Of course you could still determine which compiler you're
    # using by referencing CC or CXX.
    if CCTYPE == 'msvc':
        build_output = '/Fo' + cfg['i']
    elif CCTYPE == 'gcc':
        # Use the local obj_path variable specified above as the output file.
        # (see exp_demo example if this seems strange)
        build_output = exp("-o $obj_path")

    # both compilers need the same compile flag to build, but with a different
    # switch symbol.  arg() returns a string that is either /c or -c.
    compile_flag = arg('-c')

    # return the final build string
    return exp("$CC $build_output $CFLAGS $compile_flag $in_path")

def end_build(in_files):
    # get the path to the output executable, stored in the intermediates directory.
    # exe() removes the .exe extension if we are not on Windows.
    # exe()'s second parameter allows us to affix a string to the name if
    # the var DEBUG is set to true.
    #
    # In DEBUG=1 on windows, it will be hello_d.exe 
    # In DEBUG=0 on windows, it will be hello.exe
    # In DEBUG=1 on any other platform, it will be hello_d
    # In DEBUG=0 on any other platform, it will be hell
    out_exe_path = exe(cfg['i'] + 'hello.exe', '_d')

    if CCTYPE == 'msvc':
        build_output = '/OUT:' + out_exe_path
    else:
        build_output = '-o ' + out_exe_path

    # if obj()'s first parameter is a list, it returns a space-separated 
    # string containing all of the input files. 
    # 
    # obj()'s second parameter adds a directory to each of the obj files.
    #
    # This returns intermediates/hello.o, or intermediates/hello.obj on Windows
    obj_files = obj(in_files, cfg['i'])

    # run a shell command to link the binary
    cmd(exp("$LD $build_output $obj_files"))
    
    # copy the executable from intermediates to the current working directory
    cp(out_exe_path, '.')


# called when the user requests --clean
def clean(in_files):
    # recursively remove the intermediates directory
    rm(cfg['i'])

    # remove the executable that was built in the current configuration from
    # the current working directory.
    rm(exe('hello.exe', '_d'))



#
# main -- installs build system if build script is run directly
#
# generated code: do not edit this
#
if __name__ == '__main__':
    import sys
    import os.path
    import urllib.request
    
    print("You have run the build script directly.")
    print("Expected Usage: python jfdi.py -f %s" %
          sys.argv[0])

    DST_FILENAME = 'fdi.py'
    if os.path.exists(DST_FILENAME):
        sys.exit(0)
    print("Do you want to download the JFDI build script?")
    yesno = input('Y/n -->')
    if yesno == 'n':
        sys.exit(0)

    print("downloading jfdi.py")
    url = "https://raw.githubusercontent.com/mlabbe/jfdi/master/jfdi.py"
    urllib.request.urlretrieve(url, DST_FILENAME)
    
    print("%s downloaded." % DST_FILENAME)
    print("Usage: python %s -f %s" %
          (DST_FILENAME, sys.argv[0]))
    sys.exit(0)
